\chapter{Paradygmaty programowania}
\section{Główne paradygmaty programowania – charakterystyka i przykłady.}

\textbf{Парадигмы программирования} — это основные подходы к написанию программ. Каждая парадигма представляет собой уникальную комбинацию принципов, стилей и методологий, которые определяют подход к организации и структурированию кода. Вот некоторые из основных парадигм программирования:

\begin{itemize}
\item \textbf{Процедурное программирование:} Ориентировано на выполнение последовательности процедур или подпрограмм для обработки данных. Примеры языков: C, Fortran, COBOL.

\item \textbf{Объектно-ориентированное программирование (ООП):} Ориентировано на использование "объектов", которые объединяют данные и функции, работающие с этими данными. ООП также поддерживает наследование, полиморфизм и инкапсуляцию. Примеры языков: Java, C++, C шарп, Python.

\item \textbf{Функциональное программирование:} Фокусируется на использовании чистых функций, которые не имеют побочных эффектов. Функциональные программы строятся путем композиции функций. Примеры языков: Haskell, Lisp, Clojure.

\item \textbf{Декларативное программирование:} Ориентировано на описание желаемого результата, а не последовательности шагов для его достижения. SQL (язык запросов к базам данных) является примером декларативного языка.

\item \textbf{Логическое программирование:} Программы формулируются как наборы логических утверждений, а выполнение программы — это процесс доказательства или отрицания этих утверждений. Примером может служить Prolog.
\end{itemize}

Большинство современных языков программирования поддерживают несколько парадигм, что позволяет разработчикам выбирать подход, который наиболее подходит для решаемой задачи.

\section{Gramatyki bezkontekstowe – definicje, charakterystyki i przykłady.}

\textit{Безконтекстная грамматика} – это форма грамматики, используемая в области формальных языков. Она состоит из набора продукционных правил, каждое из которых преобразует один символ (называемый \textit{нетерминалом}) в последовательность терминалов и/или нетерминалов. Грамматика называется "безконтекстной", потому что левая часть каждого продукционного правила состоит из одного нетерминала, и, следовательно, преобразование можно выполнить вне зависимости от контекста, в котором этот нетерминал появляется.

Простым примером безконтекстной грамматики может быть грамматика, генерирующая все правильно сформированные скобочные выражения. Она может быть определена следующими продукционными правилами:

Безконтекстные грамматики играют важную роль в области компиляции и анализа программ, где они используются для определения синтаксиса языков программирования. Безконтекстные грамматики обеспечивают достаточную мощность для описания синтаксиса большинства языков программирования, в то же время они достаточно просты для анализа с помощью автоматизированных инструментов.

Более сложные типы грамматик, такие как контекстно-зависимые и контекстно-свободные грамматики, могут описывать более сложные структуры, но они также сложнее для анализа и использования.

\section{Analiza leksykalna, syntaktyczna i semantyczna kodu. }

\textbf{Анализ кода} — это процесс преобразования исходного кода в более абстрактное представление. Этот процесс обычно включает три основных этапа: лексический анализ, синтаксический анализ и семантический анализ.

\begin{itemize}
\item \textbf{Лексический анализ:} Это первый этап анализа, на котором исходный код разбивается на отдельные лексемы — наименьшие смысловые единицы кода. Лексемы могут включать ключевые слова, идентификаторы, литералы, операторы и другие компоненты синтаксиса языка программирования. Результатом лексического анализа является поток токенов, который используется для дальнейшего анализа.

\item \textbf{Синтаксический анализ:} Этот этап анализирует поток токенов, созданный на этапе лексического анализа, и создает структурированное представление кода, называемое деревом разбора. Синтаксический анализ проверяет код на соответствие синтаксическим правилам языка программирования.

\item \textbf{Семантический анализ:} На этом этапе проводится проверка кода на соответствие семантическим правилам языка. Это может включать проверку типов, проверку использования переменных и функций, проверку потока управления и т.д. Семантический анализ может обнаружить ошибки, которые не были обнаружены на этапе синтаксического анализа.
\end{itemize}

Эти этапы анализа обычно выполняются компиляторами и интерпретаторами языков программирования в процессе трансляции исходного кода в машинный код или в процессе его интерпретации.

\section{Rodzaje błędów w kontekście analizy leksykalnej, syntaktycznej i semantycznej kodu.}

В контексте анализа кода можно выделить три основных типа ошибок, соответствующих этапам анализа: лексические, синтаксические и семантические ошибки.

\begin{itemize}
\item \textbf{Лексические ошибки:} Эти ошибки возникают, когда программа содержит символы или последовательности символов, которые не могут быть правильно преобразованы в токены. Примеры лексических ошибок включают нераспознанные символы и неправильно сформированные числовые или строковые литералы. Например, в языке программирования Python следующий код вызовет лексическую ошибку из-за неправильного использования символа ':

\begin{verbatim}
print('Hello, world!)
\end{verbatim}

\item \textbf{Синтаксические ошибки:} Эти ошибки возникают, когда программа нарушает грамматические правила языка. Это может произойти, например, когда пропущена закрывающая скобка или ключевое слово. В Python следующий код вызовет синтаксическую ошибку из-за пропущенного двоеточия:

\begin{verbatim}
if x > 0
print("x is positive")
\end{verbatim}

\item \textbf{Семантические ошибки:} Эти ошибки возникают, когда программа нарушает правила языка, связанные с поведением программ, такие как правила использования типов или переменных. Например, в Python следующий код вызовет семантическую ошибку из-за использования неинициализированной переменной:

\begin{verbatim}
print(x)
\end{verbatim}
\end{itemize}

Каждый из этих типов ошибок обычно обнаруживается на соответствующем этапе анализа кода, и их исправление обычно требует изменения кода программы.



\section{Deklaratywne programowanie funkcyjne: rachunek lambda, monady}

\textbf{Декларативное программирование} — это парадигма программирования, которая фокусируется на описании, что программа должна выполнять, вместо того, чтобы описывать, как она это должна делать. \textbf{Функциональное программирование} — это подкатегория декларативного программирования, которая основана на использовании функций и их композиции.

\textbf{Расчет lambda} — это система формальной логики, которая изучает функции и их применение. В контексте функционального программирования, расчет lambda предоставляет основу для понимания функций как объектов первого класса, которые могут быть переданы в другие функции в качестве аргументов или возвращены из других функций в качестве результатов.

Вот простой пример лямбда-выражения в языке программирования Python:

add = lambda x, y: x + y

print(add(5, 3))  выведет 8 

\textbf{Монады} — это концепт из категориальной логики, который используется в некоторых функциональных языках программирования для обработки побочных эффектов в чистом функциональном стиле. В языке Haskell, например, монады используются для обработки ввода-вывода, работы с изменяемым состоянием и других операций, которые вне контекста функционального программирования обычно вызывают побочные эффекты.

\section{Deklaratywne programowanie w logice: klauzule Horne'a, nawracanie.}


\textbf{Декларативное программирование в логике} представляет собой подход к программированию, основанный на использовании формальной логики. Программы, написанные в этой парадигме, обычно представляют собой набор логических утверждений, и исполнение программы представляет собой процесс вывода на основе этих утверждений. Один из наиболее известных языков программирования, основанных на логике, — это Prolog.

\textbf{Клаузулы Хорна} — это специальный вид логических формул, который широко используется в программировании на логике. Клаузула Хорна представляет собой дизъюнкцию литералов с не более чем одним недоказанным (положительным) литералом. Программы на Prolog обычно представляют собой набор клаузул Хорна.

\textbf{Навигация (backtracking)} — это метод решения задачи, который включает перебор всех возможных решений и возврат назад, когда определенное решение оказывается неприемлемым. В контексте программирования на логике, возврат используется для исследования различных путей вывода, когда пытаются удовлетворить набор логических утверждений. Если определенный путь вывода не приводит к успешному решению, процесс может "вернуться назад" и попробовать другой путь.
